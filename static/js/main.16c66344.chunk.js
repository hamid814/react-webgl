(this["webpackJsonpreact-webgl"]=this["webpackJsonpreact-webgl"]||[]).push([[0],{36:function(n,r,e){},43:function(n,r,e){},44:function(n,r,e){},45:function(n,r,e){"use strict";e.r(r);var o=e(0),t=e(20),i=e.n(t),a=(e(36),e(22)),c=e(5),l=e(53),f=e(4),s=function(){return Object(f.jsxs)("div",{children:[Object(f.jsx)(a.b,{to:"/",children:"home"}),Object(f.jsx)(a.b,{to:"/route",children:"route"})]})},p=(e(43),function(){return Object(f.jsx)("div",{children:"Home"})}),m=function(){return Object(f.jsx)("div",{children:"Route"})},d=e(49),v=e(54),u=e(50),g=e(1),h=e(51),w=e(52),x=e(21),R=e(55),y=(e(44),function(){var n=Object(o.useRef)();return Object(o.useEffect)((function(){if(n.current){var r=new d.a({width:window.innerWidth,height:window.innerHeight,canvas:n.current}),e=r.gl,o=new v.a(e);o.position.set(0,2,4);var t=new u.a(o,{target:new g.a(0)}),i=new h.a(e,{position:{size:2,data:new Float32Array([-1,-1,3,-1,-1,3])},uv:{size:2,data:new Float32Array([0,0,2,0,0,2])}}),a=new w.a(e,{vertex:"\nprecision highp float;\n\nattribute vec2 uv;\nattribute vec2 position;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 0, 1);\n}\n",fragment:"\nprecision highp float;\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define IOR 1.45\n#define LCD 0.02\n#define RFL_STEPS 6\n#define AA 1\n\nuniform vec3 camPos;\nuniform vec3 boxSize;\nuniform float morphPower;\nuniform float boxThickness;\nuniform vec2 resolution;\nuniform float uTime;\n\nvec3 lights[2];\nvec3 projectedLights[2];\nfloat rIOR = 1.0 / IOR;\n\nstruct Reflection {\n  float power;\n  vec3 position;\n  vec3 direction;\n};\n\nmat2 rotate(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, s, -s, c);\n}\nfloat sdHexPrism(vec3 p, vec2 h) {\n  // p.yz *= rotate(uTime / 2.0);\n  // p.xz *= rotate(3.1415 * 0.5);\n  vec3 q = abs(p);\n  return max(q.z - h.y, max((q.x * 0.866025 + q.y * 0.5), q.y) - h.x);\n}\nfloat sdPlane(vec3 p) {\n  // p.xz *= Rot(uTime);\n  float d = dot(p, normalize(vec3(0.0, 0.0, 1.0)));\n  return d;\n}\nfloat sdBox(vec3 point, vec3 position, vec3 size) {\n  point.xz *= rotate(-uTime);\n  // point.xy *= rotate(3.1415 * 0.25);\n  point += position;\n  point = abs(point) - size;\n  float morphAmount = 0.1;\n  return length(max(point, 0.)) + min(max(point.x, max(point.y, point.z)), 0.) - morphAmount;\n}\nfloat sdSphere(vec3 p, float s) {\n  return length(p) - s;\n}\nfloat getDist(vec3 point) {\n  float box = sdBox(point, vec3(0.), boxSize);\n  // box = abs(box) - 0.4;\n  // float prism = sdHexPrism(point, vec2(1.5));\n  // float plane = sdPlane(point);\n\n  return box;\n  // return max(plane, prism);\n}\nfloat rayMarch(vec3 ro, vec3 rd, float sign) {\n  float dO = 0.;\n\n  for(int i = 0; i < MAX_STEPS; i++) {\n    vec3 p = ro + rd * dO;\n    float dS = getDist(p) * sign;\n    dO += dS;\n    if(dO > MAX_DIST || abs(dS) < SURF_DIST)\n      break;\n  }\n\n  return dO;\n}\nvec3 getNormal(vec3 point) {\n  float d = getDist(point);\n  vec2 e = vec2(.001, 0);\n\n  vec3 n = d - vec3(getDist(point - e.xyy), getDist(point - e.yxy), getDist(point - e.yyx));\n\n  return normalize(n);\n}\n\nvoid rotateLights(vec3 rayOrigin, vec3 camRight, vec3 camUp, vec3 camForward) {\n  lights[0] = rayOrigin + lights[0].x * camRight + lights[0].y * camUp + lights[0].z * camForward;\n  lights[1] = rayOrigin + lights[1].x * camRight + lights[1].y * camUp + lights[1].z * camForward;\n\n  projectedLights[0] = lights[0] + normalize(-lights[0]) * rayMarch(lights[0], normalize(-lights[0]), 1.0) * 0.95;\n  projectedLights[1] = lights[1] + normalize(-lights[1]) * rayMarch(lights[1], normalize(-lights[1]), 1.0) * 0.95;\n}\n\nfloat getDiffuse(vec3 point, vec3 normal) {\n  // return 1.0;\n  return max(0.0, dot(normalize(lights[0] - point), normal));\n}\n\nfloat getLight(vec3 ro, vec3 rd) {\n  rd = normalize(rd);\n  float power = 0.;\n\n  float d = rayMarch(ro, rd, -1.0);\n\n  if(d < MAX_DIST) {\n    vec3 p = ro + rd * d;\n    vec3 n = -getNormal(p);\n\n    vec3 reflection = reflect(rd, n);\n    reflection = normalize(reflection);\n    vec3 refraction = refract(-rd, n, rIOR);\n    refraction = normalize(refraction);\n\n    float rfl0 = dot(normalize(lights[0] - p), n);\n    rfl0 = smoothstep(0.95, 1.0, rfl0);\n    float rfl1 = dot(normalize(lights[1] - p), n);\n    rfl1 = smoothstep(0.75, 1.0, rfl1);\n\n    float rfr0 = dot(normalize(projectedLights[0] - p), refraction);\n    rfr0 = smoothstep(0.0, 1.0, rfr0);\n    float rfr1 = dot(normalize(projectedLights[1] - p), refraction);\n    rfr1 = smoothstep(0.0, 1.0, rfr1);\n\n    power += rfl0;\n    power += rfl1;\n    power += rfr0;\n    power += rfr1;\n  }\n\n  return power;\n}\n\nReflection getReflection(Reflection inReflection, int step) {\n  inReflection.direction = normalize(inReflection.direction);\n  Reflection ir = inReflection;\n\n  // out reflection\n  Reflection or;\n  or.power = 0.;\n\n  float d = rayMarch(ir.position, ir.direction, -1.0);\n  if(d < MAX_DIST) {\n    or.position = ir.position + ir.direction * d;\n    vec3 n = -getNormal(or.position);\n\n    vec3 reflection = reflect(ir.direction, n);\n    reflection = normalize(reflection);\n    vec3 refraction = refract(-ir.direction, n, rIOR);\n    refraction = normalize(refraction);\n\n    float rfl0 = dot(normalize(lights[0] - or.position), reflection);\n    rfl0 = smoothstep(0.99, 1.0, rfl0);\n    // rfl0 = clamp(rfl0, 0.0, 1.0);\n    float rfl1 = dot(normalize(lights[1] - or.position), reflection);\n    rfl1 = smoothstep(0.97, 1.0, rfl1);\n    // rfl1 = clamp(rfl1, 0.0, 1.0);\n\n    float rfr0 = dot(normalize(projectedLights[0] - or.position), refraction);\n    rfr0 = smoothstep(0.0, 1.0, rfr0);\n    // rfr0 = clamp(rfr0, 0.0, 1.0);\n    float rfr1 = dot(normalize(projectedLights[1] - or.position), refraction);\n    rfr1 = smoothstep(0.0, 1.0, rfr1);\n    // rfr1 = clamp(rfr1, 0.0, 1.0);\n\n    or.power += rfl0;\n    or.power += rfl1;\n    or.power += rfr0;\n    or.power += rfr1;\n\n    or.direction = reflection;\n    or.position = or.position + reflection;\n\n    // or.power = min(1.0, or.power);\n    or.power = clamp(or.power, 0.0, 1.0);\n    // or.power /= 0.8 / float(step);\n  }\n\n  return or;\n}\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 power = vec3(1.);\n\n  vec3 rayOrigin = camPos;\n  vec3 camForward = normalize(vec3(0.) - camPos);\n  vec3 camRight = normalize(cross(camForward, vec3(0., 1., 0.)));\n  vec3 camUp = normalize(cross(camRight, camForward));\n\n  lights[0] = vec3(-0.2, 1.5, 0.0);\n  lights[1] = vec3(0.2, -1.6, 0.0);\n\n  rotateLights(rayOrigin, camRight, camUp, camForward);\n\n  #if AA > 1\n  for(int m = 0; m < AA; m++)\n    for(int n = 0; n < AA; n++) {\n      vec2 o = vec2(float(m), float(n)) / float(AA) - 0.;\n      vec2 uv = (2. * gl_FragCoord.xy + o - resolution) / resolution.y;\n      uv *= 0.5;\n  #else\n      // vec2 uv = (2. * gl_FragCoord.xy - resolution) / resolution.y;\n      vec2 uv = vUv - 0.5;\n      uv.x *= resolution.x / resolution.y;\n      // uv *= 0.5;\n  #endif\n\n      vec3 rayDirection = uv.x * camRight + uv.y * camUp + camForward;\n\n      float dist = rayMarch(rayOrigin, rayDirection, 1.0);\n\n      if(dist < MAX_DIST) {\n        vec3 point = rayOrigin + rayDirection * dist;\n        vec3 normal = getNormal(point);\n\n        vec3 refractionR = refract(rayDirection, normal, rIOR + LCD);\n        vec3 refractionG = refract(rayDirection, normal, rIOR);\n        vec3 refractionB = refract(rayDirection, normal, rIOR - LCD);\n        // power += getLight(point + refractionR, refractionR);\n        // power += getDiffuse(point, normal);\n\n        Reflection rflR;\n        rflR.power = 0.;\n        rflR.direction = refractionR;\n        rflR.position = point + refractionR;\n\n        Reflection rflG;\n        rflG.power = 0.;\n        rflG.direction = refractionG;\n        rflG.position = point + refractionG;\n\n        Reflection rflB;\n        rflB.power = 0.;\n        rflB.direction = refractionB;\n        rflB.position = point + refractionB;\n\n        // for(int i = 0; i < RFL_STEPS; i++) {\n        //   rflR = getReflection(rflR, i);\n\n        //   power.r -= rflR.power;\n        // }\n        for(int i = 0; i < RFL_STEPS; i++) {\n          rflG = getReflection(rflG, i);\n\n          power -= rflG.power;\n        }\n        // for(int i = 0; i < RFL_STEPS; i++) {\n        //   rflB = getReflection(rflB, i);\n\n        //   power.b -= rflB.power;\n        // }\n        // power *= textureCube(bg, rflG.direction).rgb;\n      } else {\n        // uv.x /= resolution.x / resolution.y;\n        // uv += 0.5;\n        // power = textureCube(bg, rayDirection).rgb;\n      }\n#if AA > 1\n    }\n  // power /= float(AA * AA);\n#endif\n\n  power = clamp(power, 0.0, 1.0);\n  // power = pow(power, vec3(0.4545));\n\n  gl_FragColor = vec4(power, 1.0);\n}\n",uniforms:{uTime:{value:0},boxSize:{value:new g.a(1)},camPos:{value:new g.a(0,2,5)},resolution:{value:new x.a(window.innerWidth,window.innerHeight)}}}),c=new R.a(e,{geometry:i,program:a});requestAnimationFrame((function n(e){r.render({scene:c}),t.update(),a.uniforms.uTime.value=e/1e3,requestAnimationFrame(n)}))}}),[]),Object(f.jsx)("canvas",{ref:n})}),b=e(29),z=1e3,j=[{path:"/",Component:p},{path:"/route",Component:m}],O=function(){return Object(f.jsxs)(a.a,{children:[Object(f.jsx)(s,{}),Object(f.jsx)(y,{}),Object(f.jsx)("div",{className:"container",children:j.map((function(n){var r=n.path,e=n.Component;return Object(f.jsx)(c.a,{exact:!0,path:r,children:function(n){var r=n.match;return Object(f.jsx)(l.a,{in:null!=r,timeout:z,onEnter:function(n,r){return e=n,void b.a.fromTo(e,{opacity:0,duration:1},{opacity:1});var e},onExit:function(n){return r=n,void b.a.fromTo(r,{opacity:1,duration:1},{opacity:0});var r},classNames:"page",unmountOnExit:!0,children:Object(f.jsx)(e,{})})}},r)}))})]})};i.a.render(Object(f.jsx)(O,{}),document.getElementById("root"))}},[[45,1,2]]]);
//# sourceMappingURL=main.16c66344.chunk.js.map