{"version":3,"sources":["components/navbar/Navbar.js","routes/home/Home.js","routes/route/Route.js","components/canvas/Canvas.js","components/canvas/vert.js","components/canvas/frag1.js","routes/animations.js","App.js","index.js"],"names":["Navbar","to","Home","Route","Canvas","canvas","useRef","useEffect","current","renderer","Renderer","width","window","innerWidth","height","innerHeight","gl","camera","Camera","position","set","controls","Orbit","target","Vec3","geometry","Geometry","size","data","Float32Array","uv","program","Program","vertex","fragment","uniforms","uTime","value","boxSize","camPos","resolution","Vec2","mesh","Mesh","requestAnimationFrame","update","time","render","scene","ref","animationDuration","routes","path","Component","R","App","className","map","exact","match","Transition","in","timeout","onEnter","node","appear","elem","gsap","fromTo","opacity","duration","onExit","classNames","unmountOnExit","ReactDOM","document","getElementById"],"mappings":"yPAWeA,EATA,WACb,OACE,gCACE,cAAC,IAAD,CAAMC,GAAG,IAAT,kBACA,cAAC,IAAD,CAAMA,GAAG,SAAT,uBCFSC,G,MAJF,WACX,OAAO,yCCGMC,EAJD,WACZ,OAAO,yC,+DCwEMC,G,MAzDA,WACb,IAAMC,EAASC,mBAqDf,OAnDAC,qBAAU,WACR,GAAKF,EAAOG,QAAZ,CAIA,IAAMC,EAAW,IAAIC,IAAS,CAC5BC,MAAOC,OAAOC,WACdC,OAAQF,OAAOG,YACfV,OAAQA,EAAOG,UAGXQ,EAAKP,EAASO,GAEdC,EAAS,IAAIC,IAAOF,GAC1BC,EAAOE,SAASC,IAAI,EAAG,EAAG,GAE1B,IAAMC,EAAW,IAAIC,IAAML,EAAQ,CACjCM,OAAQ,IAAIC,IAAK,KAGbC,EAAW,IAAIC,IAASV,EAAI,CAChCG,SAAU,CAAEQ,KAAM,EAAGC,KAAM,IAAIC,aAAa,EAAE,GAAI,EAAG,GAAI,GAAI,EAAG,KAChEC,GAAI,CAAEH,KAAM,EAAGC,KAAM,IAAIC,aAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,OAGlDE,EAAU,IAAIC,IAAQhB,EAAI,CAC9BiB,OC7CM,0KD8CNC,SE9CM,ggPF+CNC,SAAU,CACRC,MAAO,CAAEC,MAAO,GAChBC,QAAS,CAAED,MAAO,IAAIb,IAAK,IAC3Be,OAAQ,CAAEF,MAAO,IAAIb,IAAK,EAAG,EAAG,IAChCgB,WAAY,CAAEH,MAAO,IAAII,IAAK7B,OAAOC,WAAYD,OAAOG,iBAItD2B,EAAO,IAAIC,IAAK3B,EAAI,CAAES,WAAUM,YAEtCa,uBAEA,SAASC,EAAOC,GACdrC,EAASsC,OAAO,CAAEC,MAAON,IAEzBrB,EAASwB,SAETd,EAAQI,SAASC,MAAMC,MAAQS,EAAO,IAEtCF,sBAAsBC,SAEvB,IAEI,wBAAQI,IAAK5C,M,QGpET6C,EAAoB,ICU3BC,EAAS,CACb,CAAEC,KAAM,IAAKC,UAAWnD,GACxB,CAAEkD,KAAM,SAAUC,UAAWC,IA8BhBC,EA3BH,WACV,OACE,eAAC,IAAD,WACE,cAAC,EAAD,IACA,cAAC,EAAD,IACA,qBAAKC,UAAU,YAAf,SACGL,EAAOM,KAAI,gBAAGL,EAAH,EAAGA,KAAMC,EAAT,EAASA,UAAT,OACV,cAAC,IAAD,CAAkBK,OAAK,EAACN,KAAMA,EAA9B,SACG,gBAAGO,EAAH,EAAGA,MAAH,OACC,cAACC,EAAA,EAAD,CACEC,GAAa,MAATF,EACJG,QAASZ,EACTa,QAAS,SAACC,EAAMC,GAAP,ODzBHC,ECyB2BF,ODxB/CG,IAAKC,OACHF,EACA,CAAEG,QAAS,EAAGC,SAAUpB,GACxB,CAAEmB,QAAS,IAJM,IAACH,GC0BNK,OAAQ,SAACP,GAAD,ODlBHE,ECkBkBF,ODjBrCG,IAAKC,OACHF,EACA,CAAEG,QAAS,EAAGC,SAAUpB,GACxB,CAAEmB,QAAS,IAJK,IAACH,GCmBLM,WAAW,OACXC,eAAa,EANf,SAQE,cAACpB,EAAD,QAVMD,YCnBtBsB,IAAS3B,OAAO,cAAC,EAAD,IAAS4B,SAASC,eAAe,W","file":"static/js/main.16c66344.chunk.js","sourcesContent":["import { Link } from 'react-router-dom';\r\n\r\nconst Navbar = () => {\r\n  return (\r\n    <div>\r\n      <Link to=\"/\">home</Link>\r\n      <Link to=\"/route\">route</Link>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Navbar;\r\n","const Home = () => {\r\n  return <div>Home</div>;\r\n};\r\n\r\nexport default Home;\r\n","const Route = () => {\r\n  return <div>Route</div>;\r\n};\r\n\r\nexport default Route;\r\n","import { useEffect, useRef } from 'react';\r\nimport {\r\n  Renderer,\r\n  Geometry,\r\n  Program,\r\n  Mesh,\r\n  Vec3,\r\n  Vec2,\r\n  Orbit,\r\n  Camera,\r\n} from 'ogl';\r\nimport vertex from './vert';\r\nimport fragment from './frag1';\r\n\r\nimport './style.css';\r\n\r\nconst Canvas = () => {\r\n  const canvas = useRef();\r\n\r\n  useEffect(() => {\r\n    if (!canvas.current) {\r\n      return;\r\n    }\r\n\r\n    const renderer = new Renderer({\r\n      width: window.innerWidth,\r\n      height: window.innerHeight,\r\n      canvas: canvas.current,\r\n    });\r\n\r\n    const gl = renderer.gl;\r\n\r\n    const camera = new Camera(gl);\r\n    camera.position.set(0, 2, 4);\r\n\r\n    const controls = new Orbit(camera, {\r\n      target: new Vec3(0),\r\n    });\r\n\r\n    const geometry = new Geometry(gl, {\r\n      position: { size: 2, data: new Float32Array([-1, -1, 3, -1, -1, 3]) },\r\n      uv: { size: 2, data: new Float32Array([0, 0, 2, 0, 0, 2]) },\r\n    });\r\n\r\n    const program = new Program(gl, {\r\n      vertex,\r\n      fragment,\r\n      uniforms: {\r\n        uTime: { value: 0 },\r\n        boxSize: { value: new Vec3(1) },\r\n        camPos: { value: new Vec3(0, 2, 5) },\r\n        resolution: { value: new Vec2(window.innerWidth, window.innerHeight) },\r\n      },\r\n    });\r\n\r\n    const mesh = new Mesh(gl, { geometry, program });\r\n\r\n    requestAnimationFrame(update);\r\n\r\n    function update(time) {\r\n      renderer.render({ scene: mesh });\r\n\r\n      controls.update();\r\n\r\n      program.uniforms.uTime.value = time / 1000;\r\n\r\n      requestAnimationFrame(update);\r\n    }\r\n  }, []);\r\n\r\n  return <canvas ref={canvas}></canvas>;\r\n};\r\n\r\nexport default Canvas;\r\n","const shader = /* glsl */ `\r\nprecision highp float;\r\n\r\nattribute vec2 uv;\r\nattribute vec2 position;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = vec4(position, 0, 1);\r\n}\r\n`;\r\n\r\nexport default shader;\r\n","const shader = /* glsl */ `\r\nprecision highp float;\r\n\r\n#define MAX_STEPS 100\r\n#define MAX_DIST 100.\r\n#define SURF_DIST .001\r\n#define IOR 1.45\r\n#define LCD 0.02\r\n#define RFL_STEPS 6\r\n#define AA 1\r\n\r\nuniform vec3 camPos;\r\nuniform vec3 boxSize;\r\nuniform float morphPower;\r\nuniform float boxThickness;\r\nuniform vec2 resolution;\r\nuniform float uTime;\r\n\r\nvec3 lights[2];\r\nvec3 projectedLights[2];\r\nfloat rIOR = 1.0 / IOR;\r\n\r\nstruct Reflection {\r\n  float power;\r\n  vec3 position;\r\n  vec3 direction;\r\n};\r\n\r\nmat2 rotate(float a) {\r\n  float s = sin(a);\r\n  float c = cos(a);\r\n  return mat2(c, s, -s, c);\r\n}\r\nfloat sdHexPrism(vec3 p, vec2 h) {\r\n  // p.yz *= rotate(uTime / 2.0);\r\n  // p.xz *= rotate(3.1415 * 0.5);\r\n  vec3 q = abs(p);\r\n  return max(q.z - h.y, max((q.x * 0.866025 + q.y * 0.5), q.y) - h.x);\r\n}\r\nfloat sdPlane(vec3 p) {\r\n  // p.xz *= Rot(uTime);\r\n  float d = dot(p, normalize(vec3(0.0, 0.0, 1.0)));\r\n  return d;\r\n}\r\nfloat sdBox(vec3 point, vec3 position, vec3 size) {\r\n  point.xz *= rotate(-uTime);\r\n  // point.xy *= rotate(3.1415 * 0.25);\r\n  point += position;\r\n  point = abs(point) - size;\r\n  float morphAmount = 0.1;\r\n  return length(max(point, 0.)) + min(max(point.x, max(point.y, point.z)), 0.) - morphAmount;\r\n}\r\nfloat sdSphere(vec3 p, float s) {\r\n  return length(p) - s;\r\n}\r\nfloat getDist(vec3 point) {\r\n  float box = sdBox(point, vec3(0.), boxSize);\r\n  // box = abs(box) - 0.4;\r\n  // float prism = sdHexPrism(point, vec2(1.5));\r\n  // float plane = sdPlane(point);\r\n\r\n  return box;\r\n  // return max(plane, prism);\r\n}\r\nfloat rayMarch(vec3 ro, vec3 rd, float sign) {\r\n  float dO = 0.;\r\n\r\n  for(int i = 0; i < MAX_STEPS; i++) {\r\n    vec3 p = ro + rd * dO;\r\n    float dS = getDist(p) * sign;\r\n    dO += dS;\r\n    if(dO > MAX_DIST || abs(dS) < SURF_DIST)\r\n      break;\r\n  }\r\n\r\n  return dO;\r\n}\r\nvec3 getNormal(vec3 point) {\r\n  float d = getDist(point);\r\n  vec2 e = vec2(.001, 0);\r\n\r\n  vec3 n = d - vec3(getDist(point - e.xyy), getDist(point - e.yxy), getDist(point - e.yyx));\r\n\r\n  return normalize(n);\r\n}\r\n\r\nvoid rotateLights(vec3 rayOrigin, vec3 camRight, vec3 camUp, vec3 camForward) {\r\n  lights[0] = rayOrigin + lights[0].x * camRight + lights[0].y * camUp + lights[0].z * camForward;\r\n  lights[1] = rayOrigin + lights[1].x * camRight + lights[1].y * camUp + lights[1].z * camForward;\r\n\r\n  projectedLights[0] = lights[0] + normalize(-lights[0]) * rayMarch(lights[0], normalize(-lights[0]), 1.0) * 0.95;\r\n  projectedLights[1] = lights[1] + normalize(-lights[1]) * rayMarch(lights[1], normalize(-lights[1]), 1.0) * 0.95;\r\n}\r\n\r\nfloat getDiffuse(vec3 point, vec3 normal) {\r\n  // return 1.0;\r\n  return max(0.0, dot(normalize(lights[0] - point), normal));\r\n}\r\n\r\nfloat getLight(vec3 ro, vec3 rd) {\r\n  rd = normalize(rd);\r\n  float power = 0.;\r\n\r\n  float d = rayMarch(ro, rd, -1.0);\r\n\r\n  if(d < MAX_DIST) {\r\n    vec3 p = ro + rd * d;\r\n    vec3 n = -getNormal(p);\r\n\r\n    vec3 reflection = reflect(rd, n);\r\n    reflection = normalize(reflection);\r\n    vec3 refraction = refract(-rd, n, rIOR);\r\n    refraction = normalize(refraction);\r\n\r\n    float rfl0 = dot(normalize(lights[0] - p), n);\r\n    rfl0 = smoothstep(0.95, 1.0, rfl0);\r\n    float rfl1 = dot(normalize(lights[1] - p), n);\r\n    rfl1 = smoothstep(0.75, 1.0, rfl1);\r\n\r\n    float rfr0 = dot(normalize(projectedLights[0] - p), refraction);\r\n    rfr0 = smoothstep(0.0, 1.0, rfr0);\r\n    float rfr1 = dot(normalize(projectedLights[1] - p), refraction);\r\n    rfr1 = smoothstep(0.0, 1.0, rfr1);\r\n\r\n    power += rfl0;\r\n    power += rfl1;\r\n    power += rfr0;\r\n    power += rfr1;\r\n  }\r\n\r\n  return power;\r\n}\r\n\r\nReflection getReflection(Reflection inReflection, int step) {\r\n  inReflection.direction = normalize(inReflection.direction);\r\n  Reflection ir = inReflection;\r\n\r\n  // out reflection\r\n  Reflection or;\r\n  or.power = 0.;\r\n\r\n  float d = rayMarch(ir.position, ir.direction, -1.0);\r\n  if(d < MAX_DIST) {\r\n    or.position = ir.position + ir.direction * d;\r\n    vec3 n = -getNormal(or.position);\r\n\r\n    vec3 reflection = reflect(ir.direction, n);\r\n    reflection = normalize(reflection);\r\n    vec3 refraction = refract(-ir.direction, n, rIOR);\r\n    refraction = normalize(refraction);\r\n\r\n    float rfl0 = dot(normalize(lights[0] - or.position), reflection);\r\n    rfl0 = smoothstep(0.99, 1.0, rfl0);\r\n    // rfl0 = clamp(rfl0, 0.0, 1.0);\r\n    float rfl1 = dot(normalize(lights[1] - or.position), reflection);\r\n    rfl1 = smoothstep(0.97, 1.0, rfl1);\r\n    // rfl1 = clamp(rfl1, 0.0, 1.0);\r\n\r\n    float rfr0 = dot(normalize(projectedLights[0] - or.position), refraction);\r\n    rfr0 = smoothstep(0.0, 1.0, rfr0);\r\n    // rfr0 = clamp(rfr0, 0.0, 1.0);\r\n    float rfr1 = dot(normalize(projectedLights[1] - or.position), refraction);\r\n    rfr1 = smoothstep(0.0, 1.0, rfr1);\r\n    // rfr1 = clamp(rfr1, 0.0, 1.0);\r\n\r\n    or.power += rfl0;\r\n    or.power += rfl1;\r\n    or.power += rfr0;\r\n    or.power += rfr1;\r\n\r\n    or.direction = reflection;\r\n    or.position = or.position + reflection;\r\n\r\n    // or.power = min(1.0, or.power);\r\n    or.power = clamp(or.power, 0.0, 1.0);\r\n    // or.power /= 0.8 / float(step);\r\n  }\r\n\r\n  return or;\r\n}\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vec3 power = vec3(1.);\r\n\r\n  vec3 rayOrigin = camPos;\r\n  vec3 camForward = normalize(vec3(0.) - camPos);\r\n  vec3 camRight = normalize(cross(camForward, vec3(0., 1., 0.)));\r\n  vec3 camUp = normalize(cross(camRight, camForward));\r\n\r\n  lights[0] = vec3(-0.2, 1.5, 0.0);\r\n  lights[1] = vec3(0.2, -1.6, 0.0);\r\n\r\n  rotateLights(rayOrigin, camRight, camUp, camForward);\r\n\r\n  #if AA > 1\r\n  for(int m = 0; m < AA; m++)\r\n    for(int n = 0; n < AA; n++) {\r\n      vec2 o = vec2(float(m), float(n)) / float(AA) - 0.;\r\n      vec2 uv = (2. * gl_FragCoord.xy + o - resolution) / resolution.y;\r\n      uv *= 0.5;\r\n  #else\r\n      // vec2 uv = (2. * gl_FragCoord.xy - resolution) / resolution.y;\r\n      vec2 uv = vUv - 0.5;\r\n      uv.x *= resolution.x / resolution.y;\r\n      // uv *= 0.5;\r\n  #endif\r\n\r\n      vec3 rayDirection = uv.x * camRight + uv.y * camUp + camForward;\r\n\r\n      float dist = rayMarch(rayOrigin, rayDirection, 1.0);\r\n\r\n      if(dist < MAX_DIST) {\r\n        vec3 point = rayOrigin + rayDirection * dist;\r\n        vec3 normal = getNormal(point);\r\n\r\n        vec3 refractionR = refract(rayDirection, normal, rIOR + LCD);\r\n        vec3 refractionG = refract(rayDirection, normal, rIOR);\r\n        vec3 refractionB = refract(rayDirection, normal, rIOR - LCD);\r\n        // power += getLight(point + refractionR, refractionR);\r\n        // power += getDiffuse(point, normal);\r\n\r\n        Reflection rflR;\r\n        rflR.power = 0.;\r\n        rflR.direction = refractionR;\r\n        rflR.position = point + refractionR;\r\n\r\n        Reflection rflG;\r\n        rflG.power = 0.;\r\n        rflG.direction = refractionG;\r\n        rflG.position = point + refractionG;\r\n\r\n        Reflection rflB;\r\n        rflB.power = 0.;\r\n        rflB.direction = refractionB;\r\n        rflB.position = point + refractionB;\r\n\r\n        // for(int i = 0; i < RFL_STEPS; i++) {\r\n        //   rflR = getReflection(rflR, i);\r\n\r\n        //   power.r -= rflR.power;\r\n        // }\r\n        for(int i = 0; i < RFL_STEPS; i++) {\r\n          rflG = getReflection(rflG, i);\r\n\r\n          power -= rflG.power;\r\n        }\r\n        // for(int i = 0; i < RFL_STEPS; i++) {\r\n        //   rflB = getReflection(rflB, i);\r\n\r\n        //   power.b -= rflB.power;\r\n        // }\r\n        // power *= textureCube(bg, rflG.direction).rgb;\r\n      } else {\r\n        // uv.x /= resolution.x / resolution.y;\r\n        // uv += 0.5;\r\n        // power = textureCube(bg, rayDirection).rgb;\r\n      }\r\n#if AA > 1\r\n    }\r\n  // power /= float(AA * AA);\r\n#endif\r\n\r\n  power = clamp(power, 0.0, 1.0);\r\n  // power = pow(power, vec3(0.4545));\r\n\r\n  gl_FragColor = vec4(power, 1.0);\r\n}\r\n`;\r\n\r\nexport default shader;\r\n","import gsap from 'gsap';\r\n\r\nexport const animationDuration = 1000;\r\n\r\nexport const enter = (elem, path) => {\r\n  gsap.fromTo(\r\n    elem,\r\n    { opacity: 0, duration: animationDuration / 1000 },\r\n    { opacity: 1 }\r\n  );\r\n};\r\n\r\nexport const exit = (elem, path) => {\r\n  gsap.fromTo(\r\n    elem,\r\n    { opacity: 1, duration: animationDuration / 1000 },\r\n    { opacity: 0 }\r\n  );\r\n};\r\n","import { BrowserRouter, Route } from 'react-router-dom';\nimport { Transition } from 'react-transition-group';\nimport Navbar from './components/navbar/Navbar';\nimport './App.css';\n\nimport Home from './routes/home/Home';\nimport { default as R } from './routes/route/Route';\n\nimport Canvas from './components/canvas/Canvas';\n\nimport { enter, exit, animationDuration } from './routes/animations';\n\nconst routes = [\n  { path: '/', Component: Home },\n  { path: '/route', Component: R },\n];\n\nconst App = () => {\n  return (\n    <BrowserRouter>\n      <Navbar />\n      <Canvas />\n      <div className=\"container\">\n        {routes.map(({ path, Component }) => (\n          <Route key={path} exact path={path}>\n            {({ match }) => (\n              <Transition\n                in={match != null}\n                timeout={animationDuration}\n                onEnter={(node, appear) => enter(node, path)}\n                onExit={(node) => exit(node, path)}\n                classNames=\"page\"\n                unmountOnExit\n              >\n                <Component />\n              </Transition>\n            )}\n          </Route>\n        ))}\n      </div>\n    </BrowserRouter>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}